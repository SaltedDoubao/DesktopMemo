# DesktopMemo 应用开发规范

本文档面向参与 DesktopMemo 开发的成员，帮助你快速了解项目结构、开发环境、构建/运行流程及常见调试路径。

## 1. 项目概览

- **解决方案**：`DesktopMemo.sln`
- **核心组件**
  - `DesktopMemo.App`：WPF 前端（UI、命令、视图模型）。
  - `DesktopMemo.Core`：领域模型与契约接口（纯 .NET 库）。
  - `DesktopMemo.Infrastructure`：文件存储、设置服务等实现。
- **数据存储**：默认写入可执行文件目录下的 `/.memodata`（Markdown + YAML Front Matter + JSON 设置）。

## 2. 开发环境要求

- Windows 10 及以上（需启用 .NET 桌面运行时支持）。
- [.NET SDK 9.0](https://dotnet.microsoft.com/zh-cn/download/dotnet/9.0)。
- 推荐 IDE：Visual Studio 2022 (17.10+) 或 JetBrains Rider / VS Code（配合 C# 插件）。

## 3. 代码结构速览

```
DesktopMemo_rebuild/
├── DesktopMemo.sln
├── docs/                      # 文档（本指南所在目录）
└── src/
    ├── DesktopMemo.App/       # 应用入口与 MVVM 层
    ├── DesktopMemo.Core/      # 模型、接口
    └── DesktopMemo.Infrastructure/  # 基础设施实现
```

### 关键目录

- `DesktopMemo.App/ViewModels/MainViewModel.cs`：应用核心逻辑，处理备忘录列表、编辑状态与设置面板。
- `DesktopMemo.Infrastructure/Repositories/FileMemoRepository.cs`：文件存储实现，维护 `content` 目录和 `index.json`。
- `DesktopMemo.App/Resources/Styles.xaml`：全局样式与主题。

## 4. 构建与输出

项目使用 `Directory.Build.props` 统一输出路径：

- 二进制产物：`artifacts/v<版本>/bin/<项目名>/<配置>/<目标框架>/`
- 中间文件：`artifacts/v<版本>/obj/<项目名>/<配置>/<目标框架>/`

`<版本>` 默认取自 `DesktopMemo.App.csproj` 的 `Version` 属性（当前为 `2.1.0`）。如需自定义，构建前可设置环境变量 `ArtifactsVersion`（示例：PowerShell 中执行 `$env:ArtifactsVersion = '2.2.0'`）。

常用命令：

```powershell
# 还原依赖（首次或更换输出目录后务必执行）
dotnet restore DesktopMemo.sln

# 调试构建
dotnet build DesktopMemo.sln --configuration Debug

# 运行应用（复用已有构建产物）
dotnet run --project src/DesktopMemo.App/DesktopMemo.App.csproj --configuration Debug
```

> **建议**：如果编译前不调整 `BaseOutputPath` / `BaseIntermediateOutputPath` 或版本号，先清理旧目录（`artifacts/vX.X.X(对应版本号)`）再执行 `restore` + `build`，避免残留文件导致重复编译错误。

## 5. 版本号管理

手动提升版本时，请确认以下位置同步更新：

- `DesktopMemo.App/DesktopMemo.App.csproj` 中的 `<Version>`、`<AssemblyVersion>`、`<FileVersion>`。
- `Directory.Build.props` 里的 `ArtifactsVersion` 默认值（决定 `artifacts/vX.Y.Z/...` 路径）。
- `MainViewModel.InitializeAppInfo()` 中的回退字符串（用于 UI 展示）。
- 文档和命令示例：搜索仓库中旧版本号（如 `2.1.0`），更新 `README.md`、`docs/development-guide.md` 等说明。

完成修改后，建议执行：

```powershell
dotnet clean DesktopMemo.sln
dotnet restore DesktopMemo.sln
dotnet build DesktopMemo.sln -c Debug
```

确保构建产物写入新的版本目录，应用 UI 亦能正确显示版本信息。

## 6. 调试技巧

- **Visual Studio**
  - 以 `DesktopMemo.App` 作为启动项目，使用 WPF 诊断工具观察绑定、布局。
  - 在 `MainViewModel` 中设置断点，调试命令执行与状态切换。
- **VS Code / Rider**
  - 使用 `dotnet run` 或 IDE 集成的调试配置，确保 `--no-build` 仅在已有构建的情况下使用。
- **数据问题排查**
  - 检查 `/.memodata/content` 中的 Markdown 文件及 `index.json`。
  - 若需要重置数据，可删除 `.memodata` 目录，应用会在下次启动时重新创建。

## 7. 发布与部署（草案）

1. 更新 `DesktopMemo.App.csproj` 中的 `Version` / `FileVersion`。
2. 执行 `.\build_exe.bat`
3. 将发布目录打包发布；若需要安装包，可结合 MSIX/WiX 等工具另行配置。

## 8. 异步编程最佳实践

⚠️ **重要**: 本节包含防止应用崩溃的关键规范，务必遵守。

### 8.1 async void 使用规范

**❌ 错误做法 - 可能导致死锁崩溃**:
```csharp
private async void Button_Click(object sender, RoutedEventArgs e)
{
    await SomeAsyncOperation(); // 危险！可能导致死锁
}
```

**✅ 正确做法**:
```csharp
private void Button_Click(object sender, RoutedEventArgs e)
{
    // 方案1: 使用 fire-and-forget 模式
    _ = Task.Run(async () => await HandleButtonClickAsync());
}

private async Task HandleButtonClickAsync()
{
    // 异步逻辑放在这里
}
```

### 8.2 UI线程与后台线程切换

**原则**: UI操作必须在UI线程，IO操作应在后台线程。

```csharp
// ✅ 正确的线程切换模式
await Task.Run(async () =>
{
    // 后台线程执行IO操作
    await _settingsService.SaveAsync(settings);

    // 切换回UI线程更新界面
    await Application.Current.Dispatcher.InvokeAsync(() =>
    {
        ViewModel.Settings = settings;
    });
});
```

### 8.3 异常处理规范

```csharp
// ✅ 完整的异常处理
try
{
    await SomeAsyncOperation();
}
catch (InvalidOperationException ex)
{
    // 特定异常的处理
    Debug.WriteLine($"操作无效: {ex.Message}");
}
catch (UnauthorizedAccessException ex)
{
    // 权限问题的处理
    ShowUserFriendlyError("权限不足");
}
catch (Exception ex)
{
    // 通用异常处理
    Debug.WriteLine($"未知错误: {ex}");
    // 提供回退方案
}
```

### 8.4 设置保存最佳实践

```csharp
// ✅ 非阻塞设置保存
if (dialog.DontShowAgain)
{
    // 不等待设置保存，避免阻塞主要操作
    _ = Task.Run(async () =>
    {
        try
        {
            var newSettings = settings with { ShowConfirmation = false };
            await _settingsService.SaveAsync(newSettings);

            // UI更新必须在UI线程
            await Application.Current.Dispatcher.InvokeAsync(() =>
            {
                Settings = newSettings;
            });
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"保存设置失败: {ex}");
            // 设置保存失败不应影响主要功能
        }
    });
}
```

### 8.5 调试异步问题

- **使用调试输出**: 关键异步操作添加 `Debug.WriteLine`
- **检查线程ID**: 确认操作在正确的线程执行
- **异常日志**: 记录完整的异常堆栈，包括内部异常

```csharp
Debug.WriteLine($"[Thread:{Thread.CurrentThread.ManagedThreadId}] 开始保存设置");
```

## 9. 代码架构规范

### 9.1 透明度和常量管理

**使用统一的常量类**:
```csharp
// ✅ 正确做法
using DesktopMemo.Core.Constants;
using DesktopMemo.Core.Helpers;

var opacity = WindowConstants.DEFAULT_TRANSPARENCY;
var percent = TransparencyHelper.ToPercent(opacity);
```

**❌ 避免硬编码**:
```csharp
// 错误 - 硬编码数值
var opacity = 0.05;
var maxOpacity = 0.4;
```

### 9.2 异常处理分级

根据异常类型提供不同级别的处理：

```csharp
try
{
    // 操作代码
}
catch (InvalidOperationException ex)
{
    // 级别1: 操作状态异常 - 用户友好提示
    SetStatus($"操作无效: {ex.Message}");
}
catch (UnauthorizedAccessException ex)
{
    // 级别2: 权限异常 - 明确权限问题
    SetStatus($"权限不足: {ex.Message}");
}
catch (IOException ex)
{
    // 级别3: IO异常 - 文件系统问题
    SetStatus($"文件操作失败: {ex.Message}");
}
catch (Exception ex)
{
    // 级别4: 未知异常 - 记录详细信息
    Debug.WriteLine($"未知异常: {ex}");
    SetStatus("操作失败，请稍后重试");
}
```

### 9.3 设置保存原子性

确保设置保存的事务性，避免数据不一致：

```csharp
// ✅ 原子性保存
try
{
    var newSettings = currentSettings with { Property = newValue };
    await _settingsService.SaveAsync(newSettings); // 先保存到文件
    CurrentSettings = newSettings; // 保存成功后才更新内存
}
catch (Exception ex)
{
    // 保存失败，内存状态保持不变
    Debug.WriteLine($"设置保存失败: {ex}");
}
```

### 9.4 Win32 API 调用规范

所有Win32 API调用都应该包含错误检查：

```csharp
// ✅ 安全的Win32 API调用
private static void SafeSetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int x, int y, int cx, int cy, uint uFlags, string operation)
{
    try
    {
        var success = SetWindowPos(hWnd, hWndInsertAfter, x, y, cx, cy, uFlags);
        if (!success)
        {
            var error = Marshal.GetLastWin32Error();
            Debug.WriteLine($"SetWindowPos失败 - 操作: {operation}, 错误代码: {error}");
        }
    }
    catch (Exception ex)
    {
        Debug.WriteLine($"SetWindowPos异常 - 操作: {operation}, 异常: {ex.Message}");
    }
}
```

## 10. 质量保障

- 当前仓库尚未引入自动化测试，计划可参考 `docs/architecture/migration-plan.md`。
- 建议 PR 前至少执行 `dotnet build` 验证通过。
- 若新增依赖或调整输出目录，请在 PR 描述中说明。

## 11. 常见问题与解决方案

| 问题类型 | 具体现象 | 解决方案 |
| --- | --- | --- |
| **编译问题** | `NETSDK1005`：找不到 `project.assets.json` | 先运行 `dotnet restore`，确认新输出目录已生成；必要时删除 `artifacts/` 重新构建。 |
| **编译问题** | Assembly 特性重复 | 删除旧的 `bin/obj` 与 `artifacts/` 后重新 `restore + build`。 |
| **UI问题** | 数据绑定未刷新 | 检查是否调用 `OnPropertyChanged`，确认 `MainViewModel` 的命令执行路径。 |
| **透明度问题** | 重启后透明度变为0%或100% | 检查设置文件完整性，验证 `TransparencyHelper` 的使用是否正确。 |
| **崩溃问题** | 勾选"不再显示"后程序卡顿崩溃 | 检查是否使用了 `async void` 事件处理器，改用 `Task.Run` + fire-and-forget 模式。 |
| **对话框问题** | 确认对话框无法显示 | 检查 `Owner` 设置是否正确，确保在UI线程上创建对话框。 |
| **设置问题** | 设置保存失败导致数据不一致 | 使用原子性保存模式：先保存文件，成功后再更新内存状态。 |
| **Win32问题** | 窗口置顶或透明度设置失败 | 检查Win32 API返回值，使用 `Marshal.GetLastWin32Error()` 获取错误代码。 |

### 调试技巧

**启用详细调试日志**:
在Debug模式下，应用会输出详细的调试信息到Visual Studio的输出窗口：

```csharp
// 查看设置加载过程
Debug.WriteLine($"设置加载: 原始透明度={settings.Transparency}, 规范化后={normalizedValue}");

// 查看异步操作状态
Debug.WriteLine($"[Thread:{Thread.CurrentThread.ManagedThreadId}] 开始保存设置");

// 查看Win32 API调用结果
Debug.WriteLine($"SetWindowPos失败 - 操作: {operation}, 错误代码: {error}");
```

**检查设置文件**:
设置文件位置：`应用目录/.memodata/settings.json`

如果设置异常，可以：
1. 删除 `settings.json` 文件重置为默认设置
2. 检查文件内容是否为有效的JSON格式
3. 查看备份文件 `settings.json.backup`（如果存在）

**性能分析**:
- 使用Visual Studio的诊断工具监控内存和CPU使用
- 注意异步操作是否阻塞UI线程
- 检查是否存在内存泄漏（特别是事件订阅）

如有更多问题，可在仓库 [issues](../../issues) 区反馈。
